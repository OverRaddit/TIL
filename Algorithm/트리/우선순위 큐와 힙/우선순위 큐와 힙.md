# 우선순위 큐와 힙

## 도입
  
> 우선순위 큐는 우선순위가 가장 높은 자료가 가장 먼저 꺼내지는 자료구조이다.  
  
어떻게 구현할까? 1. 배열 2. 연결 리스트  
  
연결리스트로 만들면 리프 노드에 접근하는 동작이 애매해진다. 따라서 __배열__을 사용하자.
  
우선순위가 가장 높은 원소를 찾는 데 __순차 탐색__을 이용하여 O(N)이 걸리고, 원소의 추가에는 O(1)이 걸릴 것이다.  
  
순차 탐색이 아닌, 이진 검색 트리를 사용하면 더 줄일 수 있다.  
  
그런데 이진 탐색보다 훨씬 단순한 구조로도 시간복잡도를 줄일 수 있다. 바로 힙을 이용하는 것이다.
  
## 힙의 정의와 구현
  
> 힙은 특정한 규칙을 만족하도록 구성된 이진 트리이다.

* 힙의 대소 관계 규칙: 부모 노드가 가진 원소는 항상 자식 노드가 가진 원소 이상이다.

* 힙의 모양 규칙
    + 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있어야 한다.
    + 마지막 레벨에 노드가 있을 때는 항상 가장 왼쪽부터 순서대로 채워져 있어야 한다.
  
## 배열을 이용한 힙의 구현
  
> A[i]에 대응되는 노드의 왼쪽 자식은 A[2*i+1]에 대응된다.
> A[i]에 대응되는 노드의 오른쪽 자식은 A[2*i+2]에 대응된다.
> A[i]에 대응되는 노드의 부모는 A[(i-1)/2]에 대응된다.

## 새 원소의 삽입
  
배열의 맨 뒤에 원소를 삽입하고, 추가한 노드의 부모 노드와 값을 비교하고 우선순위에 맞게 SWAP or 대기 한다.  
추가한 노드가 제 자리를 찾을 때 까지 반복문을 사용하여 계속 트리에서 올라가게 한다.
  
## 최대 원소 꺼내기
  
트리의 헤드, 즉 배열의 맨 앞 원소를 반환값으로 저장해두고 맨 마지막에 해당 값을 출력한다.  
  
바로 출력하지 않는 이유는 헤드가 빠진 트리에서 힙의 모양 규칙을 완성해야 하기 때문이다.  
  
배열의 맨 뒤에 있는 원소를 트리의 헤드와 SWAP한다. 배열의 맨 뒤로가버린 헤드 값은 삭제해 버린다. 맨 뒤에 있으니 모양 규칙을 맞출 추가 작업이 없다. 다음으로 헤드의 자리로 온 녀석을 자식 노드들과 비교하며 우선순위에 맞게 SWAP or 대기한다. 삽입과 다르게 트리에서 내려가는 형태이다.  
역시 제 자리를 찾을 때 까지 반복문을 사용한다.
  
## 다른 연산들
  
* 힙을 만드는 연산

* 힙 정렬

* 힙 안에 있는 원소 중 하나의 값을 증가 시키기
  
  