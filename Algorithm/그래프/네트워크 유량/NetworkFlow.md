# 1. 도입

우리는 그래프를 사용하여 최단경로를 구하는 방법을 배웠다.  
이번엔 그래프에 '용량' 이라는 개념을 알아보자.  
  
네트워크를 이용해 아주 큰 파일을 다운로드 받을 때  
최단 경로로만 1초에 1MB를 전송받는 것보다,  
  
패킷을 여러 경로로 나누어 보내 그중 일부가 좀더 먼 길을 돌아오더라도  
초당 10MB를 전송받는 것이 훨씬 이득이다.  
  
각 간선이 용량을 갖는 그래프에서 두 정점 사이에 얼마나 많은 '흐름' 혹은 유량을  
보낼 수 있는지를 계산하는 문제를 네트워크 유량(network flow) 문제라고 부른다.  
  
## **유량 네트워크**
  
    
유량 네트워크란 각 간선에 용량(capacity)이라는 추가 속성이 존재하는 방향 그래프를 말한다.  
각 간선은 유량을 흘려보낼 수 있는 파이프 역할을 한다.  
  
> 정점 u에서 v로 가는 간선의 용량을 c(u,v), 실제 흐르는 유량을 f(u,v)라고 할 때,  
>네트워크의 유량은 항상 다음 세 가지 속성을 만족한다.  
  
  
  
>1. 용량 제한 속성 : f(u,v) ≤ c(u,v)  
    각 간선의 유량은 해당 간선의 용량을 초과할 수 없다.  
>2. 유량의 대칭성 : f(u,v) = -f(v,u)  
    u에서 v로 흐르는 유량은 v가 음수의 유량을 흘리는 것으로도 해석할 수 있다.  
>3. 유량의 보존   
    각 정점에 들어오는 유량과 나가는 유량의 양은 정확히 같아야 한다.  
  
# 2. 포드-풀커슨 알고리즘
  
시작점을 source, 도착점을 sink라고 부르겠다.  
처음에는 모든 간선의 유량을 0으로 초기화한다.  
source에서 sink로 유량을 보낼 수 있는 경로를 증가경로라고 한다.  

이때, 유량을 보낼 수 있으려면 간선의 용량 - 간선의 유량인 잔여 용량이 존재해야 한다.  

> (u,v)에 대해서  
> r(u,v) = c(u,v) - f(u,v) > 0  

증가 경로를 통해 흘려보낼 수 있는 유량의 최대량은, 포함된 간선의 잔여 용량 중 가장 작은 값으로 결정된다.  

## 중간요약
  
포드-풀커슨 알고리즘은 증가 경로가 더이상 존재하지 않을 때까지 증가 경로를 찾고,  
보낼 수 있는 최대 유량을 해당 경로를 따라 보내는 작업을 반복한다.  
증가 경로를 찾는 과정은 그래프의 탐색 알고리즘을 이용한다.  

## 문제점
  
특정한 방법으로 증가 경로를 선택하여 최대 유량을 찾을 수 없는 경우가 있다.  
처음 선택한 증가 경로가 다른 증가 경로를 막아버리는 경우이다.  

이러한 경우 유량의 대칭성을 이용하여 해결해야 한다. 예를 들겠다.  
  
정점 a에서 b로가는 유량 1에 해당하는 간선이 증가 경로로 선택되었다고 가정하자.  
정점 b에서 a로가는 간선은 없다.  
a에서 b로 가는 간선을 증가경로로 사용하느라 다른 증가경로를 선택하지 못해 비효율적인 선택을 한 상황이다.  
이때 b에서 a로 가는 유량을 계산해보자.(b에서 a로가는 간선이 실제로는 존재하지 않음에 유의하자.)  
  
f(b,a) = -1이다.(f(a,b)=1에서 유량의 대칭성을 이용했다.)  
잔여 용량을 계산하면  
r(b,a) = c(b,a) - f(b,a) = 0 - (-1) = 1인 것을 알 수 있다.(없는 간선이므로 c(b,a)=0)
  
어떻게 실제로 존재하지도 않는 간선으로 유량을 보낼 수 있다는 걸까?  
**이쪽으로 흘러오는 유량을 줄이는 것은 상대에게 유량을 보내주는 것과 같은 효과를 갖는다.**  
  
여기서 생각을 조금만 더 발전시키면, 결국 두 정점간에 서로에게 이동하는 유량은 서로 상쇄시킬 수 있다는 것을 깨달을 수 있다.  
> 새 유량을 보내는 것과 기존의 유량을 상쇄하는 것은 사실상 같은 연산이다.  
  
## 포드-풀커슨 알고리즘의 구현
  
잔여 용량이 남은 간선들만을 사용하는 너비 우선 탐색을 이용해 증가 경로를 찾고,  
이를 따라 유량을 보내는 일을 더이상 증가 경로가 없을 때까지 반복한다.  
  
```c++

const int INF = 987654321;
int V;
// capacity[u][v] = u에서 v로 보낼 수 있는 용량
// flow[u][v] = u에서 v로 흘러가는 유량(반대 방향인 경우 음수)
int capacity[MAX_V][MAX_V], flow[MAX_V][MAX_V];
// flow[][]를 계산하고 총 유량을 반환한다.
int networkFlow(int source, int sink){
    // flow를 0으로 초기화한다.
    memset(flow, 0, sizeof(flow));
    int totalFlow = 0;
    while(true){
        // BFS로 증가 경로를 찾는다.
        vector<int> parent(MAX_V, -1);
        queue<int> q;
        parent[source] = source;
        q.push(source);
        while(!q.empty() && parent[sink] == -1){
            int here = q.front(); q.pop();
            for(int there=0;there<V;there++){
                if(capacity[here][there]-flow[here][there]>0 && parent[there] == -1){
                    q.push(there);
                    parent[there] = here;
                }
            }
        }
        // 증가경로가 없으면 종료한다.
        if(parent[sink] == -1) break;
        // 증가 경로를 통해 유량을 얼마나 보낼지 결정한다.
        int amount = INF;
        for(int p = sink; p!=source; p = parent[p]){
            amount = min(amount,capacity[parent[p]][p]-flow[parent[p]][p]);
        }
        // 증가 경로를 통해 유량을 보낸다.
        for(int p = sink; p!=source; p = parent[p]){
            flow[parent[p]][p] += amount;
            flow[p][parent[p]] -= amount;
        }
        totalFlow += amount;
    }
    return totalFlow;
}

```

